.. _details:

実装の詳細
==========

数式の記述
----------

関数\ :math:`f(x_0, x_1) = 2x_0 x_1 + \cos(\sin(x_0))`\ は、ライブラリを用いると以下のように書くことができる。

.. code-block:: cpp

   using tlnc::x;
   using tlnc::sin;
   using tlnc::cos;

   auto f = 2_dc * x<0> * x<1> + cos(sin(x<0>));

この関数を\ :math:`f(1, 2)`\ のように呼び出すにはヘッダ\ ``tlnc/call.hpp``\ をincludeして以下のように書く。

.. code-block:: cpp

   boost::numeric::ublas::vector<double> args(2);

   args(0) = 1.0;
   args(1) = 2.0;

   tlnc::call(f, args);

この関数を用いて数式の記述に関する実装の詳細を述べる。

演算子
^^^^^^

加算の演算子\ ``+``\ や乗算の演算子\ ``*``\ などは\ ``tlnc::expressions``\ 名前空間でオーバーロードされている。
引数を表す\ ``x<0>``\ や関数\ ``cos``\ などを呼び出した結果のオブジェクトの型は
同じ\ ``tlnc::expressions``\ 名前空間内で定義されたクラスなので、
``2_dc * x<0>``\ などと書くと
`ADL <https://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#basic.lookup.argdep>`_
によって\ ``tlnc::expressions``\ 名前空間でオーバーロードされた演算子が呼び出されることになる。
よって、オーバーロードした演算子が\ ``op_mul<Ts...>``\ のようなクラステンプレートを型に持つオブジェクトを返すようにすれば、
式テンプレートによって数式の構造を保持することができることになる。

関数
^^^^

上の例での\ ``tlnc::cos``\ や\ ``tlnc::sin``\ のような1変数関数に対する呼び出しは、引数の型が

1. ``tlnc::expressions``\ 名前空間内のクラス
2. 定数になることができるクラス
3. それ以外

のどのパターンに当てはまるかによって結果が変わる。
どのパターンに当てはまるかはSFINAEによって判定している。
定数になることができるクラスについては\ `定数 <details-expr-constant_>`_\ で説明する。
各パターンでの動作は以下の通り。

パターン1
  ``tlnc::expressions::cos<T>``\ のような\ ``tlnc::expressions``\ 名前空間内のクラステンプレートに、テンプレートパラメータとして引数の型を渡したものを型とするオブジェクトを返す。

パターン2
  コンパイル時に関数の値を評価し、その結果を数式内で扱える定数に変換する。

パターン3
  :ref:`generic`\ の関数を呼び出したときと同じ動作をする

冪関数\ ``pow``\ のような2変数関数の場合は、引数の型が

1. 両方とも\ ``tlnc::expressions``\ 名前空間内のクラス
2. 片方が\ ``tlnc::expressions``\ 名前空間内のクラスで片方が定数になることができるクラス
3. 両方が定数になることができるクラス
4. それ以外

のように場合分けし、1変数の場合と同様に結果を返す。

.. _details-expr-constant:

定数
^^^^

:cpp:class:`constant`\ クラステンプレートによって表現する。

引数
^^^^

プレースホルダ
^^^^^^^^^^^^^^
